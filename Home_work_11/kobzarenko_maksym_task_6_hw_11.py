#  Функция принимает 2 числа и делит первое число на второе. Функция должна выдать 3 ответа, независимо были ли допушены
#  ошибки в ходе выполнения функции.
def example1():
    counter = 3
    while counter > 0:
        try:
            print("Для выхода нажмите ctrl + d")  # Используем комбинацию клавишь для выхода
            x = int(input("enter a numerator: "))  # Запрашиваем от пользователя ввод числа. И преобразуем ввод от
            # пользователя к типу integer
            y = int(input("enter another denominator: "))  # Запрашиваем от пользователя ввод числа. И преобразуем ввод
            # от пользователя к типу integer
            print(x, '/', y, '=', x / y)
            counter -= 1
            print(f'\nУ вас осталось {counter} попытки')
        # Если пользоавтель в знаменатель введет 0 то мы прехватываем ошибку и выводим следующий текст
        except ZeroDivisionError:
            print(f'На ноль делить нельзя! \n У вас осталось {counter} вычисления')
            continue
        # Если пользователь ввел больше одного значения или ввел какой-то текст, то мы перехватывавем ошибку и выводим
        # следующий текст
        except ValueError:
            print(f'Вы должны написать только одно число! \n У вас осталось {counter} вычисления')
            continue
        # При нажатии ctrl + d мы ловим ошибку "EOFError" и выходим из циклa
        except EOFError:
            print('\nДо скорых встречь!')
            break
        # Выводим название спойманой ошибки и выводим к ней текст
        except Exception as errore:
            print(errore, 'Интерестно как у вас это получилось?')
            continue

    print("Надеюсь это функция была вам полезна")


# example1()

# Функция обходит коллекцию по каждому элементу и конкатенируют выбранный элемент с переди стояшим и выводит эту пару
# букв  если это строка или считает сумму этих елементов если это числa
def example2(l):
    print("\n\nExample 2")
    sum_pairs = 0  # Сюда будем записывать колличество пар в колекции
    pairs_element = []  # Сюда будем записывать пары элементов
    try:
        if len(l) == 0:  # Выводим следующее сообщение если колекция пустая
            print('Collection is empty')

        # С помощью цикла пробегаемся по каждому элементу нашей коллекции
        for i in range(len(l)):
            pairs_element.append(l[i] + l[i + 1])
    # Когда мы подошли к последниму елементу в коллекции и не можем проиндексироваться по следующему елементы то мы
    # перехватываем ошибку "IndexError" и выводим все пары коллекции и их колличество
    except IndexError:
        sum_pairs += len(pairs_element)  # Считаем колличество пар в коллекции
        print("pairs_element = ", pairs_element)  # Выводим все пары коллекции
        print(f"Count of pairs  = {sum_pairs}")  # Выводим колличество пар в коллекции
    except TypeError:
        print('Argument must be has function len() and must be of the same type')


# example2("hello my friend")

verse = '''
Жизнь коротка и быстротечна,
И лишь литература вечна.
Поэзия душа и вдохновенье,
Для сердца сладкое томленье.
'''
#  Импортируем встроенный модуль "time"
import time


# # Создаем файл с текстом из переменной "verse"
# try:
#     # Открываем наш файл для записи с помощью контекстного менеджера
#     with open(f'{time.strftime("%d.%m.%Y.%H:%M")}.txt', 'w') as file:  # Создаем файл с текстовым расширением имя
#         # которого будет состоять из даты и время когда он был записан (дд.мм.гггг. чч:мм)
#         file.write(verse)  # Записываем в файл текст содержащийся в нашей переменной
# # Если при работе с файлом произошла ошибкато мы выводим следующий текст
# except BaseException:
#     print("Ошибка при работе с файлом. Файл был закрыт")


def printUpperFile(fileName):
    '''Записать в аргумент (имя файла и его формат) в строчном литерале. Например: "some_text.txt"'''

    # # ВАРИАНТ 1
    # # Для безопасного открытия файла открываем наш его с помощью блока 'try' и 'finally'
    # try:
    #     file = open(fileName)  # Открываем наш вайл для чтения. По умолчанию файл открывается для чтения, так что можем
    #     # не указавать второй аргумент
    #     # Пробегаемся по каждой строке в файле и возводим все буквы в верхний регистр
    #     for line in file:
    #         print(line.upper(), end='')  # Выводим каждую строчку с буквами в верхнем регистре
    #         time.sleep(2)  # Выводим каждую строку с задержкой 2 секунды
    # # Ловим любую ошибку которая может выскочить и выводим ее имя
    # except BaseException as errore:
    #     print(errore)
    # # В конце обязательно закрываем файл с помощью нашего блока "finally"
    # finally:
    #     file.close()

    # ВАРИАНТ 2

    try:
        # Открываем файл для чтения с помощью контекстного менеджера. Открытие файла через контекстный менеджер "with as"
        # происходит более чисто. Если мы используем контекстный менеджер то нам блок "finally" уже не нужен, так как
        # контекстный менеджер закрывает файл автоматически.
        with open(fileName) as file:
            # Пробегаемся по каждой строке в файле и возводим все буквы в верхний регистр
            for line in file:
                print(line.upper(), end='')  # Выводим каждую строчку с буквами в верхнем регистре
    # Ловим любую ошибку которая может выскочить и выводим ее имя
    except BaseException as errore:
        print(errore, '')


# printUpperFile('11.06.2022.13:16.txt')

def main():
    example1()
    L = [10, 3, 5, 6, 9, 3]
    example2(L)
    example2([10, 3, 5, 6, "NA", 3])
    example2([10, 3, 5, 6])

    printUpperFile("doesNotExistYest.txt")
    printUpperFile("./Dessssktop/misspelled.txt")


main()
