# Создаём декоратор который проверяет если функция уже вызвалась с такими аргументами, то декоратор должен вернуть
# результат выполнения этой функции из глобальной памяти, а не вычислять его заного. Если не вызывалась с такими
# аргументами то нужно сделать: вычислить результат, положить его в память, и вернуть.
def decoratore_func(fun):
    def wrapper(*args):
        # Проверяем вызывалась ли раньше наша функции с этими аргументами. Для этого сравниваем наши аргументы с ключами
        # из нашей переменной "р"
        if args in dict_memory.keys():  # если наш аргумент равен ключу из переменной "р" то мы выводим значение этого
            # ключа
            print(dict_memory.setdefault(args))
        else:
            return fun(*args)

    return wrapper


# Создаем переменную которая будет хранить в себе все  уникальные ключи с их значениями. Ключями являються аргументы
# которые ранее вызывались функцией "func"
dict_memory: dict = {}


@decoratore_func
def func(*args: int or float):
    '''"Функции принимает неограниченное количество числовых Хешироваемых аргументов. Функция выводит сумму всех чисел
    указаных в аргументе'''
    sum_args: int or float = sum(args)  # Суммируем каждое число друг с другом аказанных в аргументе функции
    dict_memory[args] = sum_args  # Добовляем в нашу переменную ключ-значение. Где ключь - это аргументы функции, а
    # значение сумма этих аргументов
    print(sum_args)


func(5, 3, 2, 5)
func(5, 3, 2, 5)
func(5, 5, 5.5)
print(dict_memory)

